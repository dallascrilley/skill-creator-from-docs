#!/usr/bin/env python3
"""
Guardrail Generator for skill-creator-from-docs

Generates multi-layered guardrails to prevent common pitfalls:
- Layer 1: Inline warnings in templates
- Layer 2: Pre-flight validation scripts
- Layer 3: Manual checklists
- Layer 4: Automated boilerplates with error handling
"""

import json
import sys
from dataclasses import dataclass, field
from datetime import datetime
from pathlib import Path
from typing import List, Dict, Any, Optional


@dataclass
class Guardrail:
    """Represents a single guardrail check."""
    name: str
    description: str
    severity: str  # critical, high, medium, low
    check_type: str  # prerequisite, configuration, runtime, validation
    auto_fixable: bool = False
    fix_command: str = ""


@dataclass
class GuardrailSet:
    """Complete set of guardrails for a tool."""
    tool_name: str
    tool_type: str
    inline_warnings: Dict[str, List[str]] = field(default_factory=dict)
    validation_script: str = ""
    checklist: str = ""
    setup_script: str = ""
    metadata: Dict[str, Any] = field(default_factory=dict)


class GuardrailGenerator:
    """Generate multi-layered guardrails from analysis data."""

    # Validation script template
    VALIDATION_SCRIPT_TEMPLATE = '''#!/bin/bash
# validate_prereqs.sh - Generated by skill-creator-from-docs
# Tool: {tool_name}

set -euo pipefail

# Colors for output
RED='\\033[0;31m'
GREEN='\\033[0;32m'
YELLOW='\\033[1;33m'
NC='\\033[0m' # No Color

echo "üîç Validating prerequisites for {tool_name}..."
echo ""

# Check counters
checks_passed=0
checks_failed=0

{check_functions}

# Run all checks
{check_calls}

# Summary
echo ""
if [ $checks_failed -eq 0 ]; then
    echo -e "${{GREEN}}‚úÖ All $checks_passed checks passed${{NC}}"
    exit 0
else
    echo -e "${{RED}}‚ùå $checks_failed/$((checks_passed + checks_failed)) checks failed${{NC}}"
    echo ""
    echo "Please fix the failed checks before proceeding."
    exit 1
fi
'''

    CHECK_FUNCTION_TEMPLATE = '''
# {check_name}
check_{check_id}() {{
    {check_logic}
}}
'''

    # Checklist template
    CHECKLIST_TEMPLATE = '''# Pre-Flight Checklist: {tool_name}

**Generated:** {timestamp}

Run this checklist before using {tool_name} to avoid common pitfalls.

## üìã Prerequisites

{prerequisites}

## ‚öôÔ∏è Configuration

{configuration}

## ‚ö†Ô∏è Common Pitfalls

{pitfalls}

## ‚úÖ Validation

Run automated checks:

```bash
./scripts/validate_prereqs.sh
```

If all checks pass, you're ready to use {tool_name}!

## üÜò Troubleshooting

If validation fails:

{troubleshooting}
'''

    # Setup script template
    SETUP_SCRIPT_TEMPLATE = '''#!/bin/bash
# setup.sh - Automated setup for {tool_name}
# Generated by skill-creator-from-docs

set -euo pipefail

# Colors
RED='\\033[0;31m'
GREEN='\\033[0;32m'
YELLOW='\\033[1;33m'
NC='\\033[0m'

echo "üöÄ Setting up {tool_name}..."
echo ""

# Error handling
trap 'echo -e "${{RED}}‚ùå Setup failed at line $LINENO${{NC}}"; exit 1' ERR

{setup_steps}

echo ""
echo -e "${{GREEN}}‚úÖ Setup complete!${{NC}}"
echo ""
echo "Next steps:"
{next_steps}
'''

    def __init__(self, verbose: bool = True):
        self.verbose = verbose

    def log(self, message: str):
        """Log message if verbose mode enabled."""
        if self.verbose:
            print(f"[GuardrailGenerator] {message}", file=sys.stderr)

    def generate_guardrails(
        self,
        analysis: Dict[str, Any],
        templates: Optional[Dict[str, Any]] = None
    ) -> GuardrailSet:
        """
        Generate complete guardrail set from analysis data.

        Args:
            analysis: Analysis data from doc_analyzer
            templates: Optional template metadata

        Returns:
            GuardrailSet with all 4 layers
        """
        tool_type = analysis.get('tool_type', 'unknown')
        tool_name = analysis.get('metadata', {}).get('tool_name', 'Tool')

        self.log(f"Generating guardrails for {tool_name} ({tool_type})")

        # Extract data
        pitfalls = analysis.get('pitfalls', [])
        workflows = analysis.get('workflows', [])
        examples = analysis.get('examples', [])

        # Generate each layer
        guardrails = GuardrailSet(
            tool_name=tool_name,
            tool_type=tool_type,
            metadata={
                'generated_at': datetime.now().isoformat(),
                'pitfalls_count': len(pitfalls),
                'workflows_count': len(workflows)
            }
        )

        # Layer 1: Inline warnings
        self.log("Generating Layer 1: Inline warnings")
        guardrails.inline_warnings = self.generate_inline_warnings(pitfalls)

        # Layer 2: Validation script
        self.log("Generating Layer 2: Validation script")
        guardrails.validation_script = self.generate_validation_script(
            tool_name, tool_type, pitfalls, examples
        )

        # Layer 3: Checklist
        self.log("Generating Layer 3: Checklist")
        guardrails.checklist = self.generate_checklist(
            tool_name, tool_type, pitfalls, workflows
        )

        # Layer 4: Setup script
        self.log("Generating Layer 4: Setup script")
        guardrails.setup_script = self.generate_setup_script(
            tool_name, tool_type, workflows
        )

        self.log("‚úÖ Generated all 4 guardrail layers")
        return guardrails

    def generate_inline_warnings(
        self,
        pitfalls: List[Dict[str, Any]]
    ) -> Dict[str, List[str]]:
        """
        Generate inline warning comments for templates.

        Layer 1: Warnings embedded directly in template code.

        Args:
            pitfalls: List of pitfalls from analysis

        Returns:
            Dict mapping severity to list of warning comments
        """
        warnings = {
            'critical': [],
            'high': [],
            'medium': [],
            'low': []
        }

        for pitfall in pitfalls:
            description = pitfall.get('description', '')
            severity = pitfall.get('severity', 'medium')

            # Create inline comment format
            if severity == 'critical':
                warning = f"# ‚ö†Ô∏è CRITICAL: {description}"
            elif severity == 'high':
                warning = f"# ‚ö†Ô∏è PITFALL: {description}"
            elif severity == 'medium':
                warning = f"# ‚ö†Ô∏è COMMON ERROR: {description}"
            else:
                warning = f"# ‚ÑπÔ∏è NOTE: {description}"

            warnings[severity].append(warning)

        # Sort by severity
        self.log(f"Generated {sum(len(w) for w in warnings.values())} inline warnings")
        return warnings

    def generate_validation_script(
        self,
        tool_name: str,
        tool_type: str,
        pitfalls: List[Dict[str, Any]],
        examples: List[Dict[str, Any]]
    ) -> str:
        """
        Generate pre-flight validation script.

        Layer 2: Automated checks before execution.

        Args:
            tool_name: Name of the tool
            tool_type: Type (cli, api, library, framework)
            pitfalls: List of pitfalls
            examples: Code examples for context

        Returns:
            Bash script content
        """
        checks = self._identify_checks(tool_type, pitfalls, examples)

        # Generate check functions
        check_functions = []
        check_calls = []

        for i, check in enumerate(checks):
            check_id = f"{i+1:02d}_{check['name'].lower().replace(' ', '_')}"

            function = self.CHECK_FUNCTION_TEMPLATE.format(
                check_name=check['name'],
                check_id=check_id,
                check_logic=check['logic']
            )
            check_functions.append(function)

            # Add call
            check_calls.append(
                f"check_{check_id} && ((checks_passed++)) || ((checks_failed++))"
            )

        script = self.VALIDATION_SCRIPT_TEMPLATE.format(
            tool_name=tool_name,
            check_functions='\n'.join(check_functions),
            check_calls='\n'.join(check_calls)
        )

        self.log(f"Generated validation script with {len(checks)} checks")
        return script

    def _identify_checks(
        self,
        tool_type: str,
        pitfalls: List[Dict[str, Any]],
        examples: List[Dict[str, Any]]
    ) -> List[Dict[str, str]]:
        """Identify validation checks based on tool type and pitfalls."""
        checks = []

        # Common checks for all types
        checks.append({
            'name': 'Command exists',
            'logic': '''    if ! command -v TOOL_COMMAND &> /dev/null; then
        echo -e "${RED}‚ùå TOOL_COMMAND not found${NC}"
        echo "   Install with: [installation instructions]"
        return 1
    fi
    echo -e "${GREEN}‚úÖ TOOL_COMMAND available${NC}"
    return 0'''
        })

        # Type-specific checks
        if tool_type in ['api', 'library']:
            checks.append({
                'name': 'API key configured',
                'logic': '''    if [ -z "${API_KEY:-}" ]; then
        echo -e "${RED}‚ùå API_KEY not set${NC}"
        echo "   Set with: export API_KEY='your-key'"
        return 1
    fi
    echo -e "${GREEN}‚úÖ API_KEY configured${NC}"
    return 0'''
            })

        elif tool_type == 'cli':
            checks.append({
                'name': 'PATH configured',
                'logic': '''    if [ ! -d "$HOME/.local/bin" ]; then
        echo -e "${YELLOW}‚ö†Ô∏è  $HOME/.local/bin not in PATH${NC}"
        echo "   Add with: export PATH=$HOME/.local/bin:$PATH"
        return 1
    fi
    echo -e "${GREEN}‚úÖ PATH configured${NC}"
    return 0'''
            })

        # Pitfall-specific checks
        for pitfall in pitfalls[:3]:  # Top 3 pitfalls
            desc = pitfall.get('description', '')
            if 'permission' in desc.lower():
                checks.append({
                    'name': 'Permissions',
                    'logic': '''    if [ ! -r "$HOME/.config" ]; then
        echo -e "${RED}‚ùå Config directory not readable${NC}"
        return 1
    fi
    echo -e "${GREEN}‚úÖ Permissions OK${NC}"
    return 0'''
                })

        return checks

    def generate_checklist(
        self,
        tool_name: str,
        tool_type: str,
        pitfalls: List[Dict[str, Any]],
        workflows: List[Dict[str, Any]]
    ) -> str:
        """
        Generate pre-flight checklist.

        Layer 3: Manual validation checklist.

        Args:
            tool_name: Name of the tool
            tool_type: Type of tool
            pitfalls: List of pitfalls
            workflows: List of workflows

        Returns:
            Markdown checklist content
        """
        # Prerequisites section
        prerequisites = []
        prerequisites.append("- [ ] Tool installed and available in PATH")

        if tool_type in ['api', 'library']:
            prerequisites.append("- [ ] API credentials configured")
            prerequisites.append("- [ ] Network connectivity verified")

        prerequisites.append("- [ ] Dependencies installed")

        # Configuration section
        configuration = []
        configuration.append("- [ ] Environment variables set")
        configuration.append("- [ ] Configuration file created")

        if tool_type == 'cli':
            configuration.append("- [ ] Shell completion configured (optional)")

        # Pitfalls section
        pitfall_items = []
        for pitfall in pitfalls[:5]:  # Top 5 pitfalls
            desc = pitfall.get('description', '')
            severity = pitfall.get('severity', 'medium')

            if severity in ['critical', 'high']:
                marker = "üî¥"
            elif severity == 'medium':
                marker = "üü°"
            else:
                marker = "üîµ"

            pitfall_items.append(f"- [ ] {marker} Check: {desc}")

        # Troubleshooting section
        troubleshooting = []
        troubleshooting.append("1. **Installation issues**: Verify package manager is up to date")
        troubleshooting.append("2. **Configuration errors**: Check syntax in config files")
        troubleshooting.append("3. **Permission denied**: Ensure proper file permissions")
        troubleshooting.append("4. **Command not found**: Verify PATH includes installation directory")

        checklist = self.CHECKLIST_TEMPLATE.format(
            tool_name=tool_name,
            timestamp=datetime.now().strftime('%Y-%m-%d %H:%M:%S'),
            prerequisites='\n'.join(prerequisites),
            configuration='\n'.join(configuration),
            pitfalls='\n'.join(pitfall_items),
            troubleshooting='\n'.join(troubleshooting)
        )

        self.log(f"Generated checklist with {len(pitfall_items)} pitfall checks")
        return checklist

    def generate_setup_script(
        self,
        tool_name: str,
        tool_type: str,
        workflows: List[Dict[str, Any]]
    ) -> str:
        """
        Generate automated setup script.

        Layer 4: Setup automation with error handling.

        Args:
            tool_name: Name of the tool
            tool_type: Type of tool
            workflows: List of workflows

        Returns:
            Bash script content
        """
        setup_steps = []

        # Step 1: Check prerequisites
        setup_steps.append('''# Step 1: Check prerequisites
echo "Checking prerequisites..."
if ! command -v bash &> /dev/null; then
    echo -e "${RED}Error: bash not found${NC}"
    exit 1
fi
echo -e "${GREEN}‚úì Prerequisites OK${NC}"
''')

        # Step 2: Create directories
        setup_steps.append('''# Step 2: Create directories
echo "Creating directories..."
mkdir -p ~/.config/TOOL_NAME
mkdir -p ~/.local/bin
echo -e "${GREEN}‚úì Directories created${NC}"
''')

        # Step 3: Install/configure based on type
        if tool_type == 'cli':
            setup_steps.append('''# Step 3: Install CLI tool
echo "Installing CLI tool..."
# Add installation commands here
echo -e "${GREEN}‚úì CLI tool installed${NC}"
''')
        elif tool_type in ['api', 'library']:
            setup_steps.append('''# Step 3: Configure API access
echo "Configuring API access..."
if [ -z "${API_KEY:-}" ]; then
    echo -e "${YELLOW}‚ö†Ô∏è  API_KEY not set${NC}"
    echo "Please set API_KEY environment variable"
fi
echo -e "${GREEN}‚úì API configuration ready${NC}"
''')

        # Step 4: Verify installation
        setup_steps.append('''# Step 4: Verify installation
echo "Verifying installation..."
./scripts/validate_prereqs.sh
echo -e "${GREEN}‚úì Installation verified${NC}"
''')

        # Next steps
        next_steps = []
        next_steps.append('echo "1. Review the generated templates in templates/"')
        next_steps.append('echo "2. Read pre-flight checklist: checklists/pre-flight.md"')
        next_steps.append('echo "3. Try the basic template first"')

        script = self.SETUP_SCRIPT_TEMPLATE.format(
            tool_name=tool_name,
            setup_steps='\n'.join(setup_steps),
            next_steps='\n'.join(next_steps)
        )

        self.log("Generated setup script with error handling")
        return script

    def save_guardrails(
        self,
        guardrails: GuardrailSet,
        output_dir: str
    ):
        """
        Save guardrails to directory structure.

        Args:
            guardrails: GuardrailSet to save
            output_dir: Base output directory
        """
        base_path = Path(output_dir)
        base_path.mkdir(parents=True, exist_ok=True)

        self.log(f"Saving guardrails to: {output_dir}")

        # Create directory structure
        scripts_dir = base_path / 'scripts'
        checklists_dir = base_path / 'checklists'
        scripts_dir.mkdir(exist_ok=True)
        checklists_dir.mkdir(exist_ok=True)

        # Save Layer 1: Inline warnings (as JSON for integration with templates)
        warnings_file = base_path / 'inline_warnings.json'
        warnings_file.write_text(
            json.dumps(guardrails.inline_warnings, indent=2),
            encoding='utf-8'
        )

        # Save Layer 2: Validation script
        validation_file = scripts_dir / 'validate_prereqs.sh'
        validation_file.write_text(guardrails.validation_script, encoding='utf-8')
        validation_file.chmod(0o755)  # Make executable

        # Save Layer 3: Checklist
        checklist_file = checklists_dir / 'pre-flight.md'
        checklist_file.write_text(guardrails.checklist, encoding='utf-8')

        # Save Layer 4: Setup script
        setup_file = scripts_dir / 'setup.sh'
        setup_file.write_text(guardrails.setup_script, encoding='utf-8')
        setup_file.chmod(0o755)  # Make executable

        # Save metadata
        metadata = {
            'tool_name': guardrails.tool_name,
            'tool_type': guardrails.tool_type,
            'layers': {
                'inline_warnings': len(sum(guardrails.inline_warnings.values(), [])),
                'validation_script': 'scripts/validate_prereqs.sh',
                'checklist': 'checklists/pre-flight.md',
                'setup_script': 'scripts/setup.sh'
            },
            'metadata': guardrails.metadata
        }

        metadata_file = base_path / 'guardrails_metadata.json'
        metadata_file.write_text(json.dumps(metadata, indent=2), encoding='utf-8')

        self.log("‚úÖ Saved all guardrail layers")


def main():
    """CLI interface for guardrail_generator."""
    import argparse

    parser = argparse.ArgumentParser(
        description="Generate multi-layered guardrails from analyzed documentation"
    )
    parser.add_argument(
        'analysis_file',
        help='Path to analysis JSON file from doc_analyzer'
    )
    parser.add_argument(
        '--templates',
        help='Path to templates metadata JSON (optional)'
    )
    parser.add_argument(
        '--output-dir',
        default='guardrails',
        help='Directory to save guardrails (default: guardrails)'
    )
    parser.add_argument(
        '--quiet',
        action='store_true',
        help='Suppress progress messages'
    )

    args = parser.parse_args()

    try:
        # Load analysis file
        analysis_path = Path(args.analysis_file)
        if not analysis_path.exists():
            print(f"‚ùå Analysis file not found: {args.analysis_file}", file=sys.stderr)
            return 1

        with open(analysis_path, 'r', encoding='utf-8') as f:
            analysis = json.load(f)

        # Load templates if provided
        templates = None
        if args.templates:
            templates_path = Path(args.templates)
            if templates_path.exists():
                with open(templates_path, 'r', encoding='utf-8') as f:
                    templates = json.load(f)

        # Create generator
        generator = GuardrailGenerator(verbose=not args.quiet)

        # Generate guardrails
        guardrails = generator.generate_guardrails(analysis, templates)

        # Save guardrails
        generator.save_guardrails(guardrails, args.output_dir)

        # Print summary
        print(f"\n‚úÖ Guardrail generation complete!")
        print(f"   Tool: {guardrails.tool_name} ({guardrails.tool_type})")
        print(f"   Inline warnings: {len(sum(guardrails.inline_warnings.values(), []))}")
        print(f"   Output directory: {args.output_dir}")
        print(f"\n   Generated files:")
        print(f"   - scripts/validate_prereqs.sh (executable)")
        print(f"   - scripts/setup.sh (executable)")
        print(f"   - checklists/pre-flight.md")
        print(f"   - inline_warnings.json")
        print(f"   - guardrails_metadata.json")

        return 0

    except Exception as e:
        print(f"\n‚ùå Guardrail generation failed: {e}", file=sys.stderr)
        if not args.quiet:
            import traceback
            traceback.print_exc()
        return 1


if __name__ == '__main__':
    sys.exit(main())
